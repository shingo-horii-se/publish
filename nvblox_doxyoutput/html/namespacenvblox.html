<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvblox: nvblox Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="nvblox_logo_32.png" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 64px;">
  <td id="projectlogo"><img alt="Logo" src="nvblox_logo_64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvblox
   </div>
   <div id="projectbrief">Building signed distance fields for robots from sensor data on Nvidia GPUs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacenvblox.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">nvblox Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacenvblox_1_1image"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1image.html">image</a></td></tr>
<tr class="memdesc:namespacenvblox_1_1image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major access to images (on host and device) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1interpolation"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1interpolation.html">interpolation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1marching__cubes"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1marching__cubes.html">marching_cubes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1primitives"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1primitives.html">primitives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1timing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1timing.html">timing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenvblox_1_1traits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1__Unified__if_3_01T_0f_0e_4.html">_Unified_if&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1__Unified__if_3_01T_0fN_0e_4.html">_Unified_if&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1BaseLayer.html">BaseLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all layer objects.  <a href="classnvblox_1_1BaseLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A layer that contains blocks, which are stored in a hash map.  <a href="classnvblox_1_1BlockLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1BoundingPlane.html">BoundingPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bounding plane which has one "inside" direction and the other direction is "outside." Quick tests for which side of the plane you are on.  <a href="classnvblox_1_1BoundingPlane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Camera.html">Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that describes the parameters and FoV of a camera.  <a href="classnvblox_1_1Camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnvblox_1_1Color.html" title="Color, stored as 8-bit RGBA, with helper functions for commonly-used colors.">Color</a>, stored as 8-bit RGBA, with helper functions for commonly-used colors.  <a href="structnvblox_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voxel that stores the color near the surface.  <a href="structnvblox_1_1ColorVoxel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1CudaMeshBlock.html">CudaMeshBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for mesh blocks on CUDA.  <a href="structnvblox_1_1CudaMeshBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1DepthImageBackProjector.html">DepthImageBackProjector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which takes care of back projecting images on the GPU.  <a href="classnvblox_1_1DepthImageBackProjector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1device__vector.html">device_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="classnvblox_1_1unified__vector.html" title="Unified-memory CUDA vector that should only be used on trivial types as the constructors and destruct...">unified_vector</a> on device memory only.  <a href="classnvblox_1_1device__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1EsdfIntegrator.html">EsdfIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class performing (incremental) ESDF integration.  <a href="classnvblox_1_1EsdfIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1EsdfVoxel.html">EsdfVoxel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voxels that stores the distance and full direction to the nearest surface.  <a href="structnvblox_1_1EsdfVoxel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows checking for whether objects are within the field of view of a camera or not.  <a href="classnvblox_1_1Frustum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1GetLayerType.html">GetLayerType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1GetLayerType_3_01VoxelBlockLayer_3_01VoxelType_01_4_01_4.html">GetLayerType&lt; VoxelBlockLayer&lt; VoxelType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1GPUHashImpl.html">GPUHashImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1GPULayerView.html">GPULayerView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1host__vector.html">host_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="classnvblox_1_1unified__vector.html" title="Unified-memory CUDA vector that should only be used on trivial types as the constructors and destruct...">unified_vector</a> on host memory only.  <a href="classnvblox_1_1host__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major image.  <a href="classnvblox_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ImageBase.html">ImageBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ImageMasker.html">ImageMasker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to mask images based on a binary mask.  <a href="classnvblox_1_1ImageMasker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ImageView.html">ImageView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1Index3DHash.html">Index3DHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs deco hashing on block indexes.  <a href="structnvblox_1_1Index3DHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1Index3DHashMapType.html">Index3DHashMapType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1LayerCake.html">LayerCake</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a collection of layers.  <a href="classnvblox_1_1LayerCake.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct of various layer parameters of different types.  <a href="structnvblox_1_1LayerParameterStruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1LayerSerializationFunctions.html">LayerSerializationFunctions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding callbacks for serialization functions for various layer types.  <a href="structnvblox_1_1LayerSerializationFunctions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1LayerTypeRegister.html">LayerTypeRegister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows registering a layer type to be used for serialization.  <a href="classnvblox_1_1LayerTypeRegister.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Lidar.html">Lidar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for handling input LIDAR pointclouds and storing the LIDAR intrinsics.  <a href="classnvblox_1_1Lidar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Mapper.html">Mapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classnvblox_1_1Mapper.html" title="The Mapper class is what we consider the default mapping behaviour in nvblox.">Mapper</a> class is what we consider the default mapping behaviour in nvblox.  <a href="classnvblox_1_1Mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1MapperBase.html">MapperBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mapper classes wraps layers and integrators together.  <a href="classnvblox_1_1MapperBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure which holds a combined <a class="el" href="structnvblox_1_1Mesh.html" title="A structure which holds a combined Mesh for CPU access.">Mesh</a> for CPU access.  <a href="structnvblox_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1MeshBlock.html">MeshBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mesh block containing all of the triangles from this block.  <a href="structnvblox_1_1MeshBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1MeshIntegrator.html">MeshIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to integrate TSDF data into a mesh using marching cubes.  <a href="classnvblox_1_1MeshIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1MultiMapper.html">MultiMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classnvblox_1_1MultiMapper.html" title="The MultiMapper class is composed of two standard Mappers.">MultiMapper</a> class is composed of two standard Mappers.  <a href="classnvblox_1_1MultiMapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1OccupancyDecayIntegrator.html">OccupancyDecayIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classnvblox_1_1OccupancyDecayIntegrator.html" title="The OccupancyDecayIntegrator class can be used to decay (approach 0.5 occupancy probability) an occup...">OccupancyDecayIntegrator</a> class can be used to decay (approach 0.5 occupancy probability) an occupancy layer.  <a href="classnvblox_1_1OccupancyDecayIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1OccupancyVoxel.html">OccupancyVoxel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Pointcloud.html">Pointcloud</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classnvblox_1_1Pointcloud.html" title="Pointcloud that lives in either device, host or unified memory.">Pointcloud</a> that lives in either device, host or unified memory.  <a href="classnvblox_1_1Pointcloud.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ProjectiveColorIntegrator.html">ProjectiveColorIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class performing color intregration.  <a href="classnvblox_1_1ProjectiveColorIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ProjectiveIntegrator.html">ProjectiveIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pure-virtual base-class for the projective occupancy and tsdf integrators.  <a href="classnvblox_1_1ProjectiveIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ProjectiveOccupancyIntegrator.html">ProjectiveOccupancyIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class performing occupancy intregration.  <a href="classnvblox_1_1ProjectiveOccupancyIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ProjectiveTsdfIntegrator.html">ProjectiveTsdfIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class performing TSDF intregration.  <a href="classnvblox_1_1ProjectiveTsdfIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1RawIterator.html">RawIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for unified_vectors that enables us to use thrust and STL operators on our own vectors.  <a href="structnvblox_1_1RawIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1RayCaster.html">RayCaster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for casting rays through a voxelized space from origin to destination.  <a href="classnvblox_1_1RayCaster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to serialize and read a layer cake from an SQLite database.  <a href="classnvblox_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1SphereTracer.html">SphereTracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for rendering synthetic depth images using sphere tracing.  <a href="classnvblox_1_1SphereTracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1SqliteDatabase.html">SqliteDatabase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to wrap access to the C interface of SQLite in a slightly more usable format.  <a href="classnvblox_1_1SqliteDatabase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1TsdfVoxel.html">TsdfVoxel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A voxel storing TSDF (truncated signed distance field) values.  <a href="structnvblox_1_1TsdfVoxel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared_ptr for device, unified memory, and pinned host memory Things to be aware of  <a href="classnvblox_1_1unified__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1unified__vector.html">unified_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified-memory CUDA vector that should only be used on trivial types as the constructors and destructors <em>are NOT called</em>.  <a href="classnvblox_1_1unified__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1unique__types.html">unique_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1VectorCompare.html">VectorCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1ViewCalculator.html">ViewCalculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that calculates the blocks in the camera view, given intrinsic and extrinsic parameters.  <a href="classnvblox_1_1ViewCalculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block that contains 8x8x8 voxels of a given type.  <a href="structnvblox_1_1VoxelBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="classnvblox_1_1BlockLayer.html" title="A layer that contains blocks, which are stored in a hash map.">BlockLayer</a> that exclusively contains VoxelBlocks to make access easier.  <a href="classnvblox_1_1VoxelBlockLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvblox_1_1WeightingFunction.html">WeightingFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class encapsulating the supported weighting types.  <a href="classnvblox_1_1WeightingFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c56e5b887ead34e544a1cda691275d3"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_set&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>, <a class="el" href="structnvblox_1_1Index3DHash.html">Index3DHash</a>, std::equal_to&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;, Eigen::aligned_allocator&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a0c56e5b887ead34e544a1cda691275d3">Index3DSet</a></td></tr>
<tr class="separator:a0c56e5b887ead34e544a1cda691275d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d25b1bf98870a5d7242e728915cc1d5"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Vector3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a></td></tr>
<tr class="separator:a9d25b1bf98870a5d7242e728915cc1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b46690dae4dc4de729d4a9b931836"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Vector2i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a353b46690dae4dc4de729d4a9b931836">Index2D</a></td></tr>
<tr class="separator:a353b46690dae4dc4de729d4a9b931836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87a147b3363eaf7442ed521d3a9968"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a></td></tr>
<tr class="separator:a4b87a147b3363eaf7442ed521d3a9968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab038ceea5526c6254a4bfd89bed6f65d"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab038ceea5526c6254a4bfd89bed6f65d">Vector2f</a></td></tr>
<tr class="separator:ab038ceea5526c6254a4bfd89bed6f65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1a2583960d9c101856c61101b56739"><td class="memItemLeft" align="right" valign="top">typedef Eigen::AlignedBox3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a></td></tr>
<tr class="separator:acc1a2583960d9c101856c61101b56739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a99e3c413b9f0d52249e3a53816e3"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Isometry3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a></td></tr>
<tr class="separator:a187a99e3c413b9f0d52249e3a53816e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e5d9c92640e17fb508f6ba4016bd82"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a></td></tr>
<tr class="memdesc:a91e5d9c92640e17fb508f6ba4016bd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be replaced with std::byte once we go to C++17.  <br /></td></tr>
<tr class="separator:a91e5d9c92640e17fb508f6ba4016bd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188823a3393cae629221394e53ef165"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0188823a3393cae629221394e53ef165"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a0188823a3393cae629221394e53ef165">AlignedVector</a> = std::vector&lt; Type, Eigen::aligned_allocator&lt; Type &gt; &gt;</td></tr>
<tr class="memdesc:a0188823a3393cae629221394e53ef165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned Eigen containers.  <br /></td></tr>
<tr class="separator:a0188823a3393cae629221394e53ef165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af996b9675338d0ae7263ebe5a663a8e1"><td class="memItemLeft" align="right" valign="top">typedef Eigen::ParametrizedLine&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#af996b9675338d0ae7263ebe5a663a8e1">Ray</a></td></tr>
<tr class="separator:af996b9675338d0ae7263ebe5a663a8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1737bc6ae4c9df772db7f4990c533c9"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ad1737bc6ae4c9df772db7f4990c533c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad1737bc6ae4c9df772db7f4990c533c9">ConstVoxelCallbackFunction</a> = std::function&lt; void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index, const VoxelType *voxel)&gt;</td></tr>
<tr class="memdesc:ad1737bc6ae4c9df772db7f4990c533c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for calling a function on all voxels in a layer (const).  <br /></td></tr>
<tr class="separator:ad1737bc6ae4c9df772db7f4990c533c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388c9e787748f6b4f6a6b1a040ba514e"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a388c9e787748f6b4f6a6b1a040ba514e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a388c9e787748f6b4f6a6b1a040ba514e">VoxelCallbackFunction</a> = std::function&lt; void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index, VoxelType *voxel)&gt;</td></tr>
<tr class="memdesc:a388c9e787748f6b4f6a6b1a040ba514e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for calling a function on all voxels in a layer (non-const).  <br /></td></tr>
<tr class="separator:a388c9e787748f6b4f6a6b1a040ba514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab6370e27f6f8631a1364c0d2976db7"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:afab6370e27f6f8631a1364c0d2976db7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">ConstBlockCallbackFunction</a> = std::function&lt; void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index, const VoxelType *voxel)&gt;</td></tr>
<tr class="memdesc:afab6370e27f6f8631a1364c0d2976db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for calling a function on all voxels in a block (const).  <br /></td></tr>
<tr class="separator:afab6370e27f6f8631a1364c0d2976db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3b444884b9c0b9caae730c62b5beec"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:aab3b444884b9c0b9caae730c62b5beec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">BlockCallbackFunction</a> = std::function&lt; void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index, VoxelType *voxel)&gt;</td></tr>
<tr class="memdesc:aab3b444884b9c0b9caae730c62b5beec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for calling a function on all voxels in a block (non-const).  <br /></td></tr>
<tr class="separator:aab3b444884b9c0b9caae730c62b5beec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b1313d22665a2fc7d42ed4dd2fca9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a462b1313d22665a2fc7d42ed4dd2fca9">TsdfBlock</a> = <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1TsdfVoxel.html">TsdfVoxel</a> &gt;</td></tr>
<tr class="separator:a462b1313d22665a2fc7d42ed4dd2fca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd24e7c00a316481ae92646108583f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a41cd24e7c00a316481ae92646108583f">TsdfLayer</a> = <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; <a class="el" href="structnvblox_1_1TsdfVoxel.html">TsdfVoxel</a> &gt;</td></tr>
<tr class="separator:a41cd24e7c00a316481ae92646108583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ca953e59e57aeefcf8721fab9d42b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ae51ca953e59e57aeefcf8721fab9d42b">OccupancyBlock</a> = <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1OccupancyVoxel.html">OccupancyVoxel</a> &gt;</td></tr>
<tr class="separator:ae51ca953e59e57aeefcf8721fab9d42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eae2c08611e449edfed4491bd36fa18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a1eae2c08611e449edfed4491bd36fa18">OccupancyLayer</a> = <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; <a class="el" href="structnvblox_1_1OccupancyVoxel.html">OccupancyVoxel</a> &gt;</td></tr>
<tr class="separator:a1eae2c08611e449edfed4491bd36fa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c18b789b5f62cc90b9463f5b150a30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aa8c18b789b5f62cc90b9463f5b150a30">EsdfBlock</a> = <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1EsdfVoxel.html">EsdfVoxel</a> &gt;</td></tr>
<tr class="separator:aa8c18b789b5f62cc90b9463f5b150a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d96c2a51e35486f565c0d752a36a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a196d96c2a51e35486f565c0d752a36a5">EsdfLayer</a> = <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; <a class="el" href="structnvblox_1_1EsdfVoxel.html">EsdfVoxel</a> &gt;</td></tr>
<tr class="separator:a196d96c2a51e35486f565c0d752a36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1052bfb4962ba790bf76307816f8f3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ac1052bfb4962ba790bf76307816f8f3d">ColorBlock</a> = <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a> &gt;</td></tr>
<tr class="separator:ac1052bfb4962ba790bf76307816f8f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96d82304f21279b2c74ef070f9aff19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#af96d82304f21279b2c74ef070f9aff19">ColorLayer</a> = <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; <a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a> &gt;</td></tr>
<tr class="separator:af96d82304f21279b2c74ef070f9aff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dddc71de28dc4c47352193a472e0d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a45dddc71de28dc4c47352193a472e0d3">MeshLayer</a> = <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1MeshBlock.html">MeshBlock</a> &gt;</td></tr>
<tr class="separator:a45dddc71de28dc4c47352193a472e0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fb07a915c9dbfd3d7333e1080deea9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a40fb07a915c9dbfd3d7333e1080deea9">DepthImage</a> = <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt; float &gt;</td></tr>
<tr class="memdesc:a40fb07a915c9dbfd3d7333e1080deea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common Names.  <br /></td></tr>
<tr class="separator:a40fb07a915c9dbfd3d7333e1080deea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567eee9cb474b276ce1882163bdf7509"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a567eee9cb474b276ce1882163bdf7509">ColorImage</a> = <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt; <a class="el" href="structnvblox_1_1Color.html">Color</a> &gt;</td></tr>
<tr class="separator:a567eee9cb474b276ce1882163bdf7509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00b9288d204a5f385098d12fe56eb1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ae00b9288d204a5f385098d12fe56eb1a">MonoImage</a> = <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt; uint8_t &gt;</td></tr>
<tr class="separator:ae00b9288d204a5f385098d12fe56eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58edbb2cb638a043bede84fdf0f48b90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a58edbb2cb638a043bede84fdf0f48b90">DepthImageView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; float &gt;</td></tr>
<tr class="separator:a58edbb2cb638a043bede84fdf0f48b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74360011cc0e25c4af88580f5b0f507"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#af74360011cc0e25c4af88580f5b0f507">ColorImageView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; <a class="el" href="structnvblox_1_1Color.html">Color</a> &gt;</td></tr>
<tr class="separator:af74360011cc0e25c4af88580f5b0f507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa716f2a712d2e5f625d791fcce26a7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#afa716f2a712d2e5f625d791fcce26a7d">MonoImageView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; uint8_t &gt;</td></tr>
<tr class="separator:afa716f2a712d2e5f625d791fcce26a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45a16e028be0f73bb142ba2c3f8b6ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aa45a16e028be0f73bb142ba2c3f8b6ed">DepthImageConstView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; const float &gt;</td></tr>
<tr class="separator:aa45a16e028be0f73bb142ba2c3f8b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e69539aa4b41b975f7f595593d83cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a06e69539aa4b41b975f7f595593d83cc">ColorImageConstView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; const <a class="el" href="structnvblox_1_1Color.html">Color</a> &gt;</td></tr>
<tr class="separator:a06e69539aa4b41b975f7f595593d83cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75900255cfdab1120a95489e43268814"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a75900255cfdab1120a95489e43268814">MonoImageConstView</a> = <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt; const uint8_t &gt;</td></tr>
<tr class="separator:a75900255cfdab1120a95489e43268814"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a18eed59ca95a61c942eeaedc3f8ac835"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a18eed59ca95a61c942eeaedc3f8ac835">DeviceType</a> { <a class="el" href="namespacenvblox.html#a18eed59ca95a61c942eeaedc3f8ac835a2ce310327f474afc9f6774faa2f57903">kCPU</a>
, <a class="el" href="namespacenvblox.html#a18eed59ca95a61c942eeaedc3f8ac835a37ae524b76587efa776affdc5cdf2ac1">kGPU</a>
 }</td></tr>
<tr class="memdesc:a18eed59ca95a61c942eeaedc3f8ac835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the storage or processing is happening on CPU, GPU, or any future amazing hardware- accelerated platform.  <a href="namespacenvblox.html#a18eed59ca95a61c942eeaedc3f8ac835">More...</a><br /></td></tr>
<tr class="separator:a18eed59ca95a61c942eeaedc3f8ac835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb582c0d90a20d74dff447c0ac393223"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> { <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103">kDevice</a>
, <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a6cfafb52f266dacc4afe9ad59914fcd6">kUnified</a>
, <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223aab2568040d6d4e966d109b5adf7f5175">kHost</a>
 }</td></tr>
<tr class="memdesc:adb582c0d90a20d74dff447c0ac393223"><td class="mdescLeft">&#160;</td><td class="mdescRight">How GPU data is stored, either in Device-only or unified (both) memory.  <a href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">More...</a><br /></td></tr>
<tr class="separator:adb582c0d90a20d74dff447c0ac393223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af889acf516061419ed7e4c38cc6434b9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#af889acf516061419ed7e4c38cc6434b9">InterpolationType</a> { <a class="el" href="namespacenvblox.html#af889acf516061419ed7e4c38cc6434b9ad58c1cd4b17132689b2e3df64fb5b1af">kNearestNeighbor</a>
, <a class="el" href="namespacenvblox.html#af889acf516061419ed7e4c38cc6434b9aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
 }</td></tr>
<tr class="separator:af889acf516061419ed7e4c38cc6434b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76b8cc1c9b44b61cf58f4662f97bbc5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">WeightingFunctionType</a> { <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5af7d5bee02c257960661c1f7530bb46bc">kConstantWeight</a>
, <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5aed584a8afea436ac3925c2f336f97207">kConstantDropoffWeight</a>
, <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5ac8b55513c819c16a81464269132564c8">kInverseSquareWeight</a>
, <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5a8ea123f70b9ed91f4c5ef97fa2cd4b64">kInverseSquareDropoffWeight</a>
 }</td></tr>
<tr class="separator:ae76b8cc1c9b44b61cf58f4662f97bbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5fd4006b998459fe93c33d59a6f7fa"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#abf5fd4006b998459fe93c33d59a6f7fa">ProjectiveLayerType</a> { <a class="el" href="namespacenvblox.html#abf5fd4006b998459fe93c33d59a6f7faa50ef3837f3af039a7563f851682eab91">kTsdf</a>
, <a class="el" href="namespacenvblox.html#abf5fd4006b998459fe93c33d59a6f7faa421dc33c3f07425cb36e9fdea3492b21">kOccupancy</a>
 }</td></tr>
<tr class="separator:abf5fd4006b998459fe93c33d59a6f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc0d1280b92ffbb4c9f1aa143e38768c"><td class="memItemLeft" align="right" valign="top">__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#acc0d1280b92ffbb4c9f1aa143e38768c">voxelSizeToBlockSize</a> (const float voxel_size)</td></tr>
<tr class="separator:acc0d1280b92ffbb4c9f1aa143e38768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb7ee2056af83bce6f82d8fc109a7d"><td class="memItemLeft" align="right" valign="top">__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#affdb7ee2056af83bce6f82d8fc109a7d">blockSizeToVoxelSize</a> (const float block_size)</td></tr>
<tr class="separator:affdb7ee2056af83bce6f82d8fc109a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7cb25a9de0333a9f174033c2e3332"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a4fb7cb25a9de0333a9f174033c2e3332">getVoxelIndexFromPositionInLayer</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;position)</td></tr>
<tr class="memdesc:a4fb7cb25a9de0333a9f174033c2e3332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming a fixed-size voxel block, get the voxel index of a voxel at that position within a block.  <br /></td></tr>
<tr class="separator:a4fb7cb25a9de0333a9f174033c2e3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec09652af0b568f766bdf8f5ac73091"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#adec09652af0b568f766bdf8f5ac73091">getBlockIndexFromPositionInLayer</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;position)</td></tr>
<tr class="separator:adec09652af0b568f766bdf8f5ac73091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9cc929b1b05fdd42bb8b111797b385"><td class="memItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a2e9cc929b1b05fdd42bb8b111797b385">getBlockAndVoxelIndexFromPositionInLayer</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;position, <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> *block_idx, <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> *voxel_idx)</td></tr>
<tr class="separator:a2e9cc929b1b05fdd42bb8b111797b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da77dcb972ccd5958b566245ab02046"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a2da77dcb972ccd5958b566245ab02046">getPositionFromBlockIndexAndVoxelIndex</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index)</td></tr>
<tr class="memdesc:a2da77dcb972ccd5958b566245ab02046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the minimum corner (i.e., the smallest towards negative infinity of each axis).  <br /></td></tr>
<tr class="separator:a2da77dcb972ccd5958b566245ab02046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae651726a7fe422df90b521536bb69ba"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aae651726a7fe422df90b521536bb69ba">getPositionFromBlockIndex</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index)</td></tr>
<tr class="separator:aae651726a7fe422df90b521536bb69ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d7479c2dabf9b664db883e40aec0b9"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a46d7479c2dabf9b664db883e40aec0b9">getCenterPostionFromBlockIndexAndVoxelIndex</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index)</td></tr>
<tr class="memdesc:a46d7479c2dabf9b664db883e40aec0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CENTER of the voxel.  <br /></td></tr>
<tr class="separator:a46d7479c2dabf9b664db883e40aec0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b9f32c0da2867c8c8ff876bcef6a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a04b9f32c0da2867c8c8ff876bcef6a80">check_cuda</a> (cudaError_t result, char const *const func, const char *const file, int const line)</td></tr>
<tr class="separator:a04b9f32c0da2867c8c8ff876bcef6a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b35a6b08cd5433ab6230cf002c759fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a7b35a6b08cd5433ab6230cf002c759fc">warmupCuda</a> ()</td></tr>
<tr class="separator:a7b35a6b08cd5433ab6230cf002c759fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad640ac31fc054c7e04ac95dedab14a46"><td class="memItemLeft" align="right" valign="top">__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad640ac31fc054c7e04ac95dedab14a46">logOddsFromProbability</a> (float probability)</td></tr>
<tr class="separator:ad640ac31fc054c7e04ac95dedab14a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522a0eb0ae8183bf931a23f02c83f942"><td class="memItemLeft" align="right" valign="top">__host__ __device__ float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a522a0eb0ae8183bf931a23f02c83f942">probabilityFromLogOdds</a> (float log_odds)</td></tr>
<tr class="separator:a522a0eb0ae8183bf931a23f02c83f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad5347793b864b8030ae1c34b37eace"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a7ad5347793b864b8030ae1c34b37eace">toString</a> (<a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> memory_type)</td></tr>
<tr class="separator:a7ad5347793b864b8030ae1c34b37eace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86e3c49ecef5c11577d200abd4a5d02"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad86e3c49ecef5c11577d200abd4a5d02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad86e3c49ecef5c11577d200abd4a5d02">operator==</a> (const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ad86e3c49ecef5c11577d200abd4a5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41acf15abdacfa53e513ebbee32ca1a2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41acf15abdacfa53e513ebbee32ca1a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a41acf15abdacfa53e513ebbee32ca1a2">operator==</a> (std::nullptr_t, const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a41acf15abdacfa53e513ebbee32ca1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540b39e6117ea84fe5d88ff931fd891b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a540b39e6117ea84fe5d88ff931fd891b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a540b39e6117ea84fe5d88ff931fd891b">operator!=</a> (const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a540b39e6117ea84fe5d88ff931fd891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8055b1f1a067efa3636ab31a9281fc3f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8055b1f1a067efa3636ab31a9281fc3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a8055b1f1a067efa3636ab31a9281fc3f">operator!=</a> (std::nullptr_t, const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8055b1f1a067efa3636ab31a9281fc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03307af848ae5080f2fa1e4fbdcf5534"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a03307af848ae5080f2fa1e4fbdcf5534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a03307af848ae5080f2fa1e4fbdcf5534">make_unified</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a03307af848ae5080f2fa1e4fbdcf5534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b185611dd35d8e9369adb059df6afea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9b185611dd35d8e9369adb059df6afea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a9b185611dd35d8e9369adb059df6afea">make_unified</a> (<a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> memory_type, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9b185611dd35d8e9369adb059df6afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed54c98a201dc1c1599ee03f8f35fa70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed54c98a201dc1c1599ee03f8f35fa70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Unknown_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aed54c98a201dc1c1599ee03f8f35fa70">make_unified</a> (std::size_t size)</td></tr>
<tr class="separator:aed54c98a201dc1c1599ee03f8f35fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f91565d8f9966d8f21c020c65ddbb7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f91565d8f9966d8f21c020c65ddbb7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Unknown_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a7f91565d8f9966d8f21c020c65ddbb7a">make_unified</a> (std::size_t size, <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> memory_type)</td></tr>
<tr class="separator:a7f91565d8f9966d8f21c020c65ddbb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac346f7eb93e2d599cc34b5a410d3796b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac346f7eb93e2d599cc34b5a410d3796b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Known_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ac346f7eb93e2d599cc34b5a410d3796b">make_unified</a> (Args &amp;&amp;... args)=delete</td></tr>
<tr class="separator:ac346f7eb93e2d599cc34b5a410d3796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac921e530b1b004c388b36225fdf46ce8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ac921e530b1b004c388b36225fdf46ce8">getBlockIndicesTouchedByBoundingBox</a> (const float block_size, const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;aabb)</td></tr>
<tr class="memdesc:ac921e530b1b004c388b36225fdf46ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the blocks that are touched by an AABB, no matter how little.  <br /></td></tr>
<tr class="separator:ac921e530b1b004c388b36225fdf46ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7550f88d899cddf1fe0065c6cb1bc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a8f7550f88d899cddf1fe0065c6cb1bc6">getAABBOfBlock</a> (const float block_size, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index)</td></tr>
<tr class="memdesc:a8f7550f88d899cddf1fe0065c6cb1bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Axis-Aligned Bounding Box of a block.  <br /></td></tr>
<tr class="separator:a8f7550f88d899cddf1fe0065c6cb1bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fece148d48fdbf2616cf975115cfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab3fece148d48fdbf2616cf975115cfaa">getAABBOfBlocks</a> (const float block_size, const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;blocks)</td></tr>
<tr class="memdesc:ab3fece148d48fdbf2616cf975115cfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get AABB that covers ALL blocks in the block index list.  <br /></td></tr>
<tr class="separator:ab3fece148d48fdbf2616cf975115cfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af160e691719a214cb89aef11604a012b"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:af160e691719a214cb89aef11604a012b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#af160e691719a214cb89aef11604a012b">getAABBOfAllocatedBlocks</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;layer)</td></tr>
<tr class="memdesc:af160e691719a214cb89aef11604a012b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer AABB of all of the allocated blocks in the layer.  <br /></td></tr>
<tr class="separator:af160e691719a214cb89aef11604a012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb9863dc9e75130239b9931e713aaa5"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a8fb9863dc9e75130239b9931e713aaa5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a8fb9863dc9e75130239b9931e713aaa5">getAllocatedBlocksWithinAABB</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;layer, const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;aabb)</td></tr>
<tr class="memdesc:a8fb9863dc9e75130239b9931e713aaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the allocated blocks that are within a given AABB.  <br /></td></tr>
<tr class="separator:a8fb9863dc9e75130239b9931e713aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec28f37483058ef2883ea873ea3f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad3ec28f37483058ef2883ea873ea3f13">getAABBOfObservedVoxels</a> (const <a class="el" href="namespacenvblox.html#a196d96c2a51e35486f565c0d752a36a5">EsdfLayer</a> &amp;layer)</td></tr>
<tr class="memdesc:ad3ec28f37483058ef2883ea873ea3f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer AABB of all of the blocks that contain observed voxels in an ESDF layer.  <br /></td></tr>
<tr class="separator:ad3ec28f37483058ef2883ea873ea3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5b7e63075bc1119b0edbe58f8e99b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a9d5b7e63075bc1119b0edbe58f8e99b1">getAABBOfObservedVoxels</a> (const <a class="el" href="namespacenvblox.html#a41cd24e7c00a316481ae92646108583f">TsdfLayer</a> &amp;layer, const float min_weight=1e-4)</td></tr>
<tr class="memdesc:a9d5b7e63075bc1119b0edbe58f8e99b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer AABB of all of the blocks that contain observed voxels in an TSDF layer.  <br /></td></tr>
<tr class="separator:a9d5b7e63075bc1119b0edbe58f8e99b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad939d259752408dc069ec818acd9a949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad939d259752408dc069ec818acd9a949">getAABBOfObservedVoxels</a> (const <a class="el" href="namespacenvblox.html#af96d82304f21279b2c74ef070f9aff19">ColorLayer</a> &amp;layer, const float min_weight=1e-4)</td></tr>
<tr class="memdesc:ad939d259752408dc069ec818acd9a949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer AABB of all of the blocks that contain observed voxels in an <a class="el" href="structnvblox_1_1Color.html" title="Color, stored as 8-bit RGBA, with helper functions for commonly-used colors.">Color</a> layer.  <br /></td></tr>
<tr class="separator:ad939d259752408dc069ec818acd9a949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea96648dace1f0db185c0932733594f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aeea96648dace1f0db185c0932733594f">getBlocksWithinRadius</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;input_blocks, float block_size, const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;center, float radius)</td></tr>
<tr class="separator:aeea96648dace1f0db185c0932733594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1df1b500c275abd3552c74a01658e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#adf1df1b500c275abd3552c74a01658e6">getBlocksOutsideRadius</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;input_blocks, float block_size, const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;center, float radius)</td></tr>
<tr class="separator:adf1df1b500c275abd3552c74a01658e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db94b92cfb98fd29ece567c172c7e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a36db94b92cfb98fd29ece567c172c7e1">getBlocksWithinRadiusOfAABB</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;input_blocks, float block_size, const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;aabb, float radius)</td></tr>
<tr class="separator:a36db94b92cfb98fd29ece567c172c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f5a2c479618906828b62e82690732"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:ada0f5a2c479618906828b62e82690732"><td class="memTemplItemLeft" align="right" valign="top">__host__ std::vector&lt; BlockType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ada0f5a2c479618906828b62e82690732">getBlockPtrsFromIndices</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;block_indices, <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; *layer_ptr)</td></tr>
<tr class="memdesc:ada0f5a2c479618906828b62e82690732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of BlockIndices on host, to a list of (non-const) device pointers on host.  <br /></td></tr>
<tr class="separator:ada0f5a2c479618906828b62e82690732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bbaae47fb1f678138db31fa3a7bad6"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a76bbaae47fb1f678138db31fa3a7bad6"><td class="memTemplItemLeft" align="right" valign="top">__host__ std::vector&lt; const BlockType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a76bbaae47fb1f678138db31fa3a7bad6">getBlockPtrsFromIndices</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;block_indices, const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;layer_ptr)</td></tr>
<tr class="memdesc:a76bbaae47fb1f678138db31fa3a7bad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of BlockIndices on host, to a list of (const) device pointers on host.  <br /></td></tr>
<tr class="separator:a76bbaae47fb1f678138db31fa3a7bad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7858b23f9966e9d530bf999c6d9dc1"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a5c7858b23f9966e9d530bf999c6d9dc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a5c7858b23f9966e9d530bf999c6d9dc1">allocateBlocksWhereRequired</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;block_indices, <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; *layer)</td></tr>
<tr class="memdesc:a5c7858b23f9966e9d530bf999c6d9dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates blocks in the block_indices list which are not already allocated.  <br /></td></tr>
<tr class="separator:a5c7858b23f9966e9d530bf999c6d9dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1134fae2a499abdb031e39a5b534643a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a1134fae2a499abdb031e39a5b534643a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">WeightingFunctionType</a> &amp;weighting_function_type)</td></tr>
<tr class="separator:a1134fae2a499abdb031e39a5b534643a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ae3aa42c62ddb96209361fef3babcd"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:ab2ae3aa42c62ddb96209361fef3babcd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab2ae3aa42c62ddb96209361fef3babcd">getBlockAtPosition</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;layer, const Eigen::Vector3f &amp;position, const BlockType **data)</td></tr>
<tr class="memdesc:ab2ae3aa42c62ddb96209361fef3babcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Block.  <br /></td></tr>
<tr class="separator:ab2ae3aa42c62ddb96209361fef3babcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923cd9f93e5934518e22f7a5f33d8d78"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a923cd9f93e5934518e22f7a5f33d8d78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a923cd9f93e5934518e22f7a5f33d8d78">getVoxelAtPosition</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;layer, const Eigen::Vector3f &amp;position, const VoxelType **data)</td></tr>
<tr class="memdesc:a923cd9f93e5934518e22f7a5f33d8d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Voxel.  <br /></td></tr>
<tr class="separator:a923cd9f93e5934518e22f7a5f33d8d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd778ad4b5a410398362558151736b9"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a1cd778ad4b5a410398362558151736b9"><td class="memTemplItemLeft" align="right" valign="top">const VoxelType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a1cd778ad4b5a410398362558151736b9">getVoxelAtBlockAndVoxelIndex</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;layer, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;voxel_index)</td></tr>
<tr class="memdesc:a1cd778ad4b5a410398362558151736b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for voxelized types.  <br /></td></tr>
<tr class="separator:a1cd778ad4b5a410398362558151736b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f851e9d9f630b069291e2582d4744"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ac17f851e9d9f630b069291e2582d4744"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ac17f851e9d9f630b069291e2582d4744">callFunctionOnAllVoxels</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;layer, <a class="el" href="namespacenvblox.html#ad1737bc6ae4c9df772db7f4990c533c9">ConstVoxelCallbackFunction</a>&lt; VoxelType &gt; callback)</td></tr>
<tr class="memdesc:ac17f851e9d9f630b069291e2582d4744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function on all voxels in a layer (const).  <br /></td></tr>
<tr class="separator:ac17f851e9d9f630b069291e2582d4744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6284af341feff2614afbe0a62e8b17f5"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a6284af341feff2614afbe0a62e8b17f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a6284af341feff2614afbe0a62e8b17f5">callFunctionOnAllVoxels</a> (<a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; *layer, <a class="el" href="namespacenvblox.html#a388c9e787748f6b4f6a6b1a040ba514e">VoxelCallbackFunction</a>&lt; VoxelType &gt; callback)</td></tr>
<tr class="memdesc:a6284af341feff2614afbe0a62e8b17f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function on all voxels in a layer (non-const).  <br /></td></tr>
<tr class="separator:a6284af341feff2614afbe0a62e8b17f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c9416b53472314d8dfa30e886d6616"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a61c9416b53472314d8dfa30e886d6616"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a61c9416b53472314d8dfa30e886d6616">callFunctionOnAllVoxels</a> (const <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &amp;block, <a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">ConstBlockCallbackFunction</a>&lt; VoxelType &gt; callback)</td></tr>
<tr class="separator:a61c9416b53472314d8dfa30e886d6616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8804a7406d60e6a2ab265f36bb30ed0"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ab8804a7406d60e6a2ab265f36bb30ed0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab8804a7406d60e6a2ab265f36bb30ed0">callFunctionOnAllVoxels</a> (<a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; *block, <a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">BlockCallbackFunction</a>&lt; VoxelType &gt; callback)</td></tr>
<tr class="separator:ab8804a7406d60e6a2ab265f36bb30ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5dd1c630c4d9f195fc5129f9a91c2e"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a5c5dd1c630c4d9f195fc5129f9a91c2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a5c5dd1c630c4d9f195fc5129f9a91c2e">callFunctionOnAllBlocks</a> (const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;layer, <a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">ConstBlockCallbackFunction</a>&lt; BlockType &gt; callback)</td></tr>
<tr class="separator:a5c5dd1c630c4d9f195fc5129f9a91c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aefb02650fdf067d9b1ca5ef3dcde47"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a8aefb02650fdf067d9b1ca5ef3dcde47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a8aefb02650fdf067d9b1ca5ef3dcde47">callFunctionOnAllBlocks</a> (<a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; *layer, <a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">BlockCallbackFunction</a>&lt; BlockType &gt; callback)</td></tr>
<tr class="separator:a8aefb02650fdf067d9b1ca5ef3dcde47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06424d9c839e12bd1d548dfd795a97"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a8d06424d9c839e12bd1d548dfd795a97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a8d06424d9c839e12bd1d548dfd795a97">setBlockBytesZeroOnGPU</a> (BlockType *block_device_ptr)</td></tr>
<tr class="memdesc:a8d06424d9c839e12bd1d548dfd795a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the memory of the block to 0 on the GPU.  <br /></td></tr>
<tr class="separator:a8d06424d9c839e12bd1d548dfd795a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77c97b5cf7abe06613cdbd8bbf6f443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab77c97b5cf7abe06613cdbd8bbf6f443">setColorBlockGrayOnGPU</a> (<a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a> &gt; *block_device_ptr)</td></tr>
<tr class="memdesc:ab77c97b5cf7abe06613cdbd8bbf6f443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all of the default colors to gray on a GPU.  <br /></td></tr>
<tr class="separator:ab77c97b5cf7abe06613cdbd8bbf6f443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cae54124801d270d0a29985d0ad2145"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:a9cae54124801d270d0a29985d0ad2145"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a9cae54124801d270d0a29985d0ad2145">sizeArgumentFromVoxelSize</a> (float voxel_size)</td></tr>
<tr class="separator:a9cae54124801d270d0a29985d0ad2145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1693c36a85f8b6f0f993ee6391188eb0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a1693c36a85f8b6f0f993ee6391188eb0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;camera)</td></tr>
<tr class="separator:a1693c36a85f8b6f0f993ee6391188eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75b710e0da73064821f31e9baf821c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ae75b710e0da73064821f31e9baf821c1">camerasAreEquivalent</a> (const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;camera_1, const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;camera_2, const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;T_L_C1, const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;T_L_C2)</td></tr>
<tr class="separator:ae75b710e0da73064821f31e9baf821c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5943b902513096b8979a4493ca55d75c"><td class="memItemLeft" align="right" valign="top">__host__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a5943b902513096b8979a4493ca55d75c">operator==</a> (const <a class="el" href="classnvblox_1_1Lidar.html">Lidar</a> &amp;lhs, const <a class="el" href="classnvblox_1_1Lidar.html">Lidar</a> &amp;rhs)</td></tr>
<tr class="separator:a5943b902513096b8979a4493ca55d75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e3a3efb322790a7a033be6874d5d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a3f6e3a3efb322790a7a033be6874d5d2">transformPointcloudOnGPU</a> (const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;T_out_in, const <a class="el" href="classnvblox_1_1Pointcloud.html">Pointcloud</a> &amp;pointcloud_in, <a class="el" href="classnvblox_1_1Pointcloud.html">Pointcloud</a> *pointcloud_out_ptr)</td></tr>
<tr class="memdesc:a3f6e3a3efb322790a7a033be6874d5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the points in a pointcloud into another frame.  <br /></td></tr>
<tr class="separator:a3f6e3a3efb322790a7a033be6874d5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5b5a3a002bf96d85d9f518551649ce"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:a4a5b5a3a002bf96d85d9f518551649ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a4a5b5a3a002bf96d85d9f518551649ce">serializeBlock</a> (const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; BlockType &gt; &amp;block)</td></tr>
<tr class="separator:a4a5b5a3a002bf96d85d9f518551649ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ef5974444b610c02404d45eb926161"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a90ef5974444b610c02404d45eb926161"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a90ef5974444b610c02404d45eb926161">serializeBlock</a> (const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; const <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;block)</td></tr>
<tr class="separator:a90ef5974444b610c02404d45eb926161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa302f8bddb39d26891618146393d24ce"><td class="memTemplParams" colspan="2">template&lt;typename BlockType &gt; </td></tr>
<tr class="memitem:aa302f8bddb39d26891618146393d24ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aa302f8bddb39d26891618146393d24ce">deserializeBlock</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;bytes, <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; BlockType &gt; &amp;block)</td></tr>
<tr class="separator:aa302f8bddb39d26891618146393d24ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b773d5dc129c91a64fcb2cfec2a50"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a2d4b773d5dc129c91a64fcb2cfec2a50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a2d4b773d5dc129c91a64fcb2cfec2a50">deserializeBlock</a> (const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;bytes, <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;block)</td></tr>
<tr class="separator:a2d4b773d5dc129c91a64fcb2cfec2a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4635fca5584da87fcaff8ed8f4be69ac"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:a4635fca5584da87fcaff8ed8f4be69ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1LayerSerializationFunctions.html">LayerSerializationFunctions</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a4635fca5584da87fcaff8ed8f4be69ac">bindDefaultFunctions</a> ()</td></tr>
<tr class="memdesc:a4635fca5584da87fcaff8ed8f4be69ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind default functions for the given types.  <br /></td></tr>
<tr class="separator:a4635fca5584da87fcaff8ed8f4be69ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed96b00838d2adfba230bd0709a16c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a6ed96b00838d2adfba230bd0709a16c4">registerCommonTypes</a> ()</td></tr>
<tr class="memdesc:a6ed96b00838d2adfba230bd0709a16c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all the common layer types for serialization.  <br /></td></tr>
<tr class="separator:a6ed96b00838d2adfba230bd0709a16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a8f5534a4b6789066b937136b35b85"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:ad5a8f5534a4b6789066b937136b35b85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ad5a8f5534a4b6789066b937136b35b85">serializeLayerParameters</a> (const LayerType &amp;layer)</td></tr>
<tr class="separator:ad5a8f5534a4b6789066b937136b35b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68738a6de44353303d7c4c8662508bfa"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:a68738a6de44353303d7c4c8662508bfa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a68738a6de44353303d7c4c8662508bfa">getLayerDataIndices</a> (const LayerType &amp;layer)</td></tr>
<tr class="separator:a68738a6de44353303d7c4c8662508bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99810f5f74b03fbf6dcd807a6c83c4eb"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:a99810f5f74b03fbf6dcd807a6c83c4eb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a99810f5f74b03fbf6dcd807a6c83c4eb">serializeLayerDataAtIndex</a> (const LayerType &amp;layer, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;index)</td></tr>
<tr class="separator:a99810f5f74b03fbf6dcd807a6c83c4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a3afd4da91d0a6d84e422fb18a1ff0"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a54a3afd4da91d0a6d84e422fb18a1ff0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a54a3afd4da91d0a6d84e422fb18a1ff0">serializeLayerParameters</a> (const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;layer)</td></tr>
<tr class="separator:a54a3afd4da91d0a6d84e422fb18a1ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609662db86c4b574f6c08694edf2f0ce"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a609662db86c4b574f6c08694edf2f0ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a609662db86c4b574f6c08694edf2f0ce">getLayerDataIndices</a> (const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;layer)</td></tr>
<tr class="separator:a609662db86c4b574f6c08694edf2f0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef435b778e89ff71d0326897f3ccbfa"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a7ef435b778e89ff71d0326897f3ccbfa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a7ef435b778e89ff71d0326897f3ccbfa">serializeLayerDataAtIndex</a> (const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;layer, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;index)</td></tr>
<tr class="separator:a7ef435b778e89ff71d0326897f3ccbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42544cd06768a1ed8fed4554f388092"><td class="memTemplParams" colspan="2">template&lt;typename LayerType &gt; </td></tr>
<tr class="memitem:ac42544cd06768a1ed8fed4554f388092"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ac42544cd06768a1ed8fed4554f388092">addDataToLayer</a> (const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;index, const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;data, LayerType *layer)</td></tr>
<tr class="separator:ac42544cd06768a1ed8fed4554f388092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172bba665e591f7562a8c890a8584276"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a172bba665e591f7562a8c890a8584276"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a172bba665e591f7562a8c890a8584276">deserializeLayerParameters</a> (<a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> memory_type, const <a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a> &amp;params)</td></tr>
<tr class="separator:a172bba665e591f7562a8c890a8584276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf8b6f75f8582239582862b49409c9b"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:accf8b6f75f8582239582862b49409c9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#accf8b6f75f8582239582862b49409c9b">addDataToLayer</a> (const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;index, const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;data, <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; *layer)</td></tr>
<tr class="separator:accf8b6f75f8582239582862b49409c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aca11bf4da09302e5daa400017eb6092b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">WeightingFunctionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#aca11bf4da09302e5daa400017eb6092b">kDefaultWeightingFunctionType</a></td></tr>
<tr class="separator:aca11bf4da09302e5daa400017eb6092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab715cffa6ff1964ebcd0a536fd2f2fd1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#ab715cffa6ff1964ebcd0a536fd2f2fd1">kDefaultImageMemoryType</a> = <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103">MemoryType::kDevice</a></td></tr>
<tr class="separator:ab715cffa6ff1964ebcd0a536fd2f2fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fccc8c7879835b1e30a86ac96f9a0f9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvblox.html#a4fccc8c7879835b1e30a86ac96f9a0f9">kDefaultPointcloudMemoryType</a> = <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103">MemoryType::kDevice</a></td></tr>
<tr class="separator:a4fccc8c7879835b1e30a86ac96f9a0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0188823a3393cae629221394e53ef165" name="a0188823a3393cae629221394e53ef165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0188823a3393cae629221394e53ef165">&#9670;&#160;</a></span>AlignedVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a0188823a3393cae629221394e53ef165">nvblox::AlignedVector</a> = typedef std::vector&lt;Type, Eigen::aligned_allocator&lt;Type&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned Eigen containers. </p>

</div>
</div>
<a id="acc1a2583960d9c101856c61101b56739" name="acc1a2583960d9c101856c61101b56739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1a2583960d9c101856c61101b56739">&#9670;&#160;</a></span>AxisAlignedBoundingBox</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::AlignedBox3f <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">nvblox::AxisAlignedBoundingBox</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3b444884b9c0b9caae730c62b5beec" name="aab3b444884b9c0b9caae730c62b5beec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3b444884b9c0b9caae730c62b5beec">&#9670;&#160;</a></span>BlockCallbackFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">nvblox::BlockCallbackFunction</a> = typedef std::function&lt;void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; block_index, BlockType* block)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for calling a function on all voxels in a block (non-const). </p>

</div>
</div>
<a id="a91e5d9c92640e17fb508f6ba4016bd82" name="a91e5d9c92640e17fb508f6ba4016bd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e5d9c92640e17fb508f6ba4016bd82">&#9670;&#160;</a></span>Byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">nvblox::Byte</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This can be replaced with std::byte once we go to C++17. </p>

</div>
</div>
<a id="ac1052bfb4962ba790bf76307816f8f3d" name="ac1052bfb4962ba790bf76307816f8f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1052bfb4962ba790bf76307816f8f3d">&#9670;&#160;</a></span>ColorBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#ac1052bfb4962ba790bf76307816f8f3d">nvblox::ColorBlock</a> = typedef <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt;<a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a567eee9cb474b276ce1882163bdf7509" name="a567eee9cb474b276ce1882163bdf7509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567eee9cb474b276ce1882163bdf7509">&#9670;&#160;</a></span>ColorImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a567eee9cb474b276ce1882163bdf7509">nvblox::ColorImage</a> = typedef <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt;<a class="el" href="structnvblox_1_1Color.html">Color</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06e69539aa4b41b975f7f595593d83cc" name="a06e69539aa4b41b975f7f595593d83cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e69539aa4b41b975f7f595593d83cc">&#9670;&#160;</a></span>ColorImageConstView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a06e69539aa4b41b975f7f595593d83cc">nvblox::ColorImageConstView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;const <a class="el" href="structnvblox_1_1Color.html">Color</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af74360011cc0e25c4af88580f5b0f507" name="af74360011cc0e25c4af88580f5b0f507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74360011cc0e25c4af88580f5b0f507">&#9670;&#160;</a></span>ColorImageView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#af74360011cc0e25c4af88580f5b0f507">nvblox::ColorImageView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;<a class="el" href="structnvblox_1_1Color.html">Color</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af96d82304f21279b2c74ef070f9aff19" name="af96d82304f21279b2c74ef070f9aff19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96d82304f21279b2c74ef070f9aff19">&#9670;&#160;</a></span>ColorLayer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#af96d82304f21279b2c74ef070f9aff19">nvblox::ColorLayer</a> = typedef <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt;<a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afab6370e27f6f8631a1364c0d2976db7" name="afab6370e27f6f8631a1364c0d2976db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab6370e27f6f8631a1364c0d2976db7">&#9670;&#160;</a></span>ConstBlockCallbackFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">nvblox::ConstBlockCallbackFunction</a> = typedef std::function&lt;void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; block_index, const BlockType* block)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for calling a function on all voxels in a block (const). </p>
<p>Accessors for calling a function on all blocks in a layer. </p>

</div>
</div>
<a id="ad1737bc6ae4c9df772db7f4990c533c9" name="ad1737bc6ae4c9df772db7f4990c533c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1737bc6ae4c9df772db7f4990c533c9">&#9670;&#160;</a></span>ConstVoxelCallbackFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#ad1737bc6ae4c9df772db7f4990c533c9">nvblox::ConstVoxelCallbackFunction</a> = typedef std::function&lt;void(const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; voxel_index, const VoxelType* voxel)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for calling a function on all voxels in a layer (const). </p>

</div>
</div>
<a id="a40fb07a915c9dbfd3d7333e1080deea9" name="a40fb07a915c9dbfd3d7333e1080deea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fb07a915c9dbfd3d7333e1080deea9">&#9670;&#160;</a></span>DepthImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a40fb07a915c9dbfd3d7333e1080deea9">nvblox::DepthImage</a> = typedef <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common Names. </p>

</div>
</div>
<a id="aa45a16e028be0f73bb142ba2c3f8b6ed" name="aa45a16e028be0f73bb142ba2c3f8b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45a16e028be0f73bb142ba2c3f8b6ed">&#9670;&#160;</a></span>DepthImageConstView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#aa45a16e028be0f73bb142ba2c3f8b6ed">nvblox::DepthImageConstView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;const float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58edbb2cb638a043bede84fdf0f48b90" name="a58edbb2cb638a043bede84fdf0f48b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58edbb2cb638a043bede84fdf0f48b90">&#9670;&#160;</a></span>DepthImageView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a58edbb2cb638a043bede84fdf0f48b90">nvblox::DepthImageView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8c18b789b5f62cc90b9463f5b150a30" name="aa8c18b789b5f62cc90b9463f5b150a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c18b789b5f62cc90b9463f5b150a30">&#9670;&#160;</a></span>EsdfBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#aa8c18b789b5f62cc90b9463f5b150a30">nvblox::EsdfBlock</a> = typedef <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt;<a class="el" href="structnvblox_1_1EsdfVoxel.html">EsdfVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a196d96c2a51e35486f565c0d752a36a5" name="a196d96c2a51e35486f565c0d752a36a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196d96c2a51e35486f565c0d752a36a5">&#9670;&#160;</a></span>EsdfLayer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a196d96c2a51e35486f565c0d752a36a5">nvblox::EsdfLayer</a> = typedef <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt;<a class="el" href="structnvblox_1_1EsdfVoxel.html">EsdfVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a353b46690dae4dc4de729d4a9b931836" name="a353b46690dae4dc4de729d4a9b931836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353b46690dae4dc4de729d4a9b931836">&#9670;&#160;</a></span>Index2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Vector2i <a class="el" href="namespacenvblox.html#a353b46690dae4dc4de729d4a9b931836">nvblox::Index2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d25b1bf98870a5d7242e728915cc1d5" name="a9d25b1bf98870a5d7242e728915cc1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d25b1bf98870a5d7242e728915cc1d5">&#9670;&#160;</a></span>Index3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Vector3i <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">nvblox::Index3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c56e5b887ead34e544a1cda691275d3" name="a0c56e5b887ead34e544a1cda691275d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c56e5b887ead34e544a1cda691275d3">&#9670;&#160;</a></span>Index3DSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_set&lt;<a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>, <a class="el" href="structnvblox_1_1Index3DHash.html">Index3DHash</a>, std::equal_to&lt;<a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&gt;, Eigen::aligned_allocator&lt;<a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&gt; &gt; <a class="el" href="namespacenvblox.html#a0c56e5b887ead34e544a1cda691275d3">nvblox::Index3DSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45dddc71de28dc4c47352193a472e0d3" name="a45dddc71de28dc4c47352193a472e0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dddc71de28dc4c47352193a472e0d3">&#9670;&#160;</a></span>MeshLayer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a45dddc71de28dc4c47352193a472e0d3">nvblox::MeshLayer</a> = typedef <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt;<a class="el" href="structnvblox_1_1MeshBlock.html">MeshBlock</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae00b9288d204a5f385098d12fe56eb1a" name="ae00b9288d204a5f385098d12fe56eb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00b9288d204a5f385098d12fe56eb1a">&#9670;&#160;</a></span>MonoImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#ae00b9288d204a5f385098d12fe56eb1a">nvblox::MonoImage</a> = typedef <a class="el" href="classnvblox_1_1Image.html">Image</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75900255cfdab1120a95489e43268814" name="a75900255cfdab1120a95489e43268814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75900255cfdab1120a95489e43268814">&#9670;&#160;</a></span>MonoImageConstView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a75900255cfdab1120a95489e43268814">nvblox::MonoImageConstView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;const uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa716f2a712d2e5f625d791fcce26a7d" name="afa716f2a712d2e5f625d791fcce26a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa716f2a712d2e5f625d791fcce26a7d">&#9670;&#160;</a></span>MonoImageView</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#afa716f2a712d2e5f625d791fcce26a7d">nvblox::MonoImageView</a> = typedef <a class="el" href="classnvblox_1_1ImageView.html">ImageView</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae51ca953e59e57aeefcf8721fab9d42b" name="ae51ca953e59e57aeefcf8721fab9d42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ca953e59e57aeefcf8721fab9d42b">&#9670;&#160;</a></span>OccupancyBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#ae51ca953e59e57aeefcf8721fab9d42b">nvblox::OccupancyBlock</a> = typedef <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt;<a class="el" href="structnvblox_1_1OccupancyVoxel.html">OccupancyVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eae2c08611e449edfed4491bd36fa18" name="a1eae2c08611e449edfed4491bd36fa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eae2c08611e449edfed4491bd36fa18">&#9670;&#160;</a></span>OccupancyLayer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a1eae2c08611e449edfed4491bd36fa18">nvblox::OccupancyLayer</a> = typedef <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt;<a class="el" href="structnvblox_1_1OccupancyVoxel.html">OccupancyVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af996b9675338d0ae7263ebe5a663a8e1" name="af996b9675338d0ae7263ebe5a663a8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af996b9675338d0ae7263ebe5a663a8e1">&#9670;&#160;</a></span>Ray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::ParametrizedLine&lt;float, 3&gt; <a class="el" href="namespacenvblox.html#af996b9675338d0ae7263ebe5a663a8e1">nvblox::Ray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a187a99e3c413b9f0d52249e3a53816e3" name="a187a99e3c413b9f0d52249e3a53816e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a99e3c413b9f0d52249e3a53816e3">&#9670;&#160;</a></span>Transform</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Isometry3f <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">nvblox::Transform</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a462b1313d22665a2fc7d42ed4dd2fca9" name="a462b1313d22665a2fc7d42ed4dd2fca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b1313d22665a2fc7d42ed4dd2fca9">&#9670;&#160;</a></span>TsdfBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a462b1313d22665a2fc7d42ed4dd2fca9">nvblox::TsdfBlock</a> = typedef <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt;<a class="el" href="structnvblox_1_1TsdfVoxel.html">TsdfVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41cd24e7c00a316481ae92646108583f" name="a41cd24e7c00a316481ae92646108583f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cd24e7c00a316481ae92646108583f">&#9670;&#160;</a></span>TsdfLayer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a41cd24e7c00a316481ae92646108583f">nvblox::TsdfLayer</a> = typedef <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt;<a class="el" href="structnvblox_1_1TsdfVoxel.html">TsdfVoxel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab038ceea5526c6254a4bfd89bed6f65d" name="ab038ceea5526c6254a4bfd89bed6f65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab038ceea5526c6254a4bfd89bed6f65d">&#9670;&#160;</a></span>Vector2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Vector2f <a class="el" href="namespacenvblox.html#ab038ceea5526c6254a4bfd89bed6f65d">nvblox::Vector2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b87a147b3363eaf7442ed521d3a9968" name="a4b87a147b3363eaf7442ed521d3a9968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b87a147b3363eaf7442ed521d3a9968">&#9670;&#160;</a></span>Vector3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Vector3f <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">nvblox::Vector3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a388c9e787748f6b4f6a6b1a040ba514e" name="a388c9e787748f6b4f6a6b1a040ba514e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388c9e787748f6b4f6a6b1a040ba514e">&#9670;&#160;</a></span>VoxelCallbackFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvblox.html#a388c9e787748f6b4f6a6b1a040ba514e">nvblox::VoxelCallbackFunction</a> = typedef std::function&lt;void( const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; block_index, const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a>&amp; voxel_index, VoxelType* voxel)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for calling a function on all voxels in a layer (non-const). </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a18eed59ca95a61c942eeaedc3f8ac835" name="a18eed59ca95a61c942eeaedc3f8ac835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eed59ca95a61c942eeaedc3f8ac835">&#9670;&#160;</a></span>DeviceType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacenvblox.html#a18eed59ca95a61c942eeaedc3f8ac835">nvblox::DeviceType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the storage or processing is happening on CPU, GPU, or any future amazing hardware- accelerated platform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a18eed59ca95a61c942eeaedc3f8ac835a2ce310327f474afc9f6774faa2f57903" name="a18eed59ca95a61c942eeaedc3f8ac835a2ce310327f474afc9f6774faa2f57903"></a>kCPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a18eed59ca95a61c942eeaedc3f8ac835a37ae524b76587efa776affdc5cdf2ac1" name="a18eed59ca95a61c942eeaedc3f8ac835a37ae524b76587efa776affdc5cdf2ac1"></a>kGPU&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af889acf516061419ed7e4c38cc6434b9" name="af889acf516061419ed7e4c38cc6434b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af889acf516061419ed7e4c38cc6434b9">&#9670;&#160;</a></span>InterpolationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacenvblox.html#af889acf516061419ed7e4c38cc6434b9">nvblox::InterpolationType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af889acf516061419ed7e4c38cc6434b9ad58c1cd4b17132689b2e3df64fb5b1af" name="af889acf516061419ed7e4c38cc6434b9ad58c1cd4b17132689b2e3df64fb5b1af"></a>kNearestNeighbor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af889acf516061419ed7e4c38cc6434b9aac97f0008bcf7c7fe4f2ff94160e1385" name="af889acf516061419ed7e4c38cc6434b9aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="adb582c0d90a20d74dff447c0ac393223" name="adb582c0d90a20d74dff447c0ac393223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb582c0d90a20d74dff447c0ac393223">&#9670;&#160;</a></span>MemoryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">nvblox::MemoryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How GPU data is stored, either in Device-only or unified (both) memory. </p>
<p>NOTE(alexmillane): tag: c++17, switch to constexpr when we move to c++17. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103" name="adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103"></a>kDevice&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adb582c0d90a20d74dff447c0ac393223a6cfafb52f266dacc4afe9ad59914fcd6" name="adb582c0d90a20d74dff447c0ac393223a6cfafb52f266dacc4afe9ad59914fcd6"></a>kUnified&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adb582c0d90a20d74dff447c0ac393223aab2568040d6d4e966d109b5adf7f5175" name="adb582c0d90a20d74dff447c0ac393223aab2568040d6d4e966d109b5adf7f5175"></a>kHost&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abf5fd4006b998459fe93c33d59a6f7fa" name="abf5fd4006b998459fe93c33d59a6f7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5fd4006b998459fe93c33d59a6f7fa">&#9670;&#160;</a></span>ProjectiveLayerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacenvblox.html#abf5fd4006b998459fe93c33d59a6f7fa">nvblox::ProjectiveLayerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abf5fd4006b998459fe93c33d59a6f7faa50ef3837f3af039a7563f851682eab91" name="abf5fd4006b998459fe93c33d59a6f7faa50ef3837f3af039a7563f851682eab91"></a>kTsdf&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf5fd4006b998459fe93c33d59a6f7faa421dc33c3f07425cb36e9fdea3492b21" name="abf5fd4006b998459fe93c33d59a6f7faa421dc33c3f07425cb36e9fdea3492b21"></a>kOccupancy&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae76b8cc1c9b44b61cf58f4662f97bbc5" name="ae76b8cc1c9b44b61cf58f4662f97bbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76b8cc1c9b44b61cf58f4662f97bbc5">&#9670;&#160;</a></span>WeightingFunctionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">nvblox::WeightingFunctionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae76b8cc1c9b44b61cf58f4662f97bbc5af7d5bee02c257960661c1f7530bb46bc" name="ae76b8cc1c9b44b61cf58f4662f97bbc5af7d5bee02c257960661c1f7530bb46bc"></a>kConstantWeight&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae76b8cc1c9b44b61cf58f4662f97bbc5aed584a8afea436ac3925c2f336f97207" name="ae76b8cc1c9b44b61cf58f4662f97bbc5aed584a8afea436ac3925c2f336f97207"></a>kConstantDropoffWeight&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae76b8cc1c9b44b61cf58f4662f97bbc5ac8b55513c819c16a81464269132564c8" name="ae76b8cc1c9b44b61cf58f4662f97bbc5ac8b55513c819c16a81464269132564c8"></a>kInverseSquareWeight&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae76b8cc1c9b44b61cf58f4662f97bbc5a8ea123f70b9ed91f4c5ef97fa2cd4b64" name="ae76b8cc1c9b44b61cf58f4662f97bbc5a8ea123f70b9ed91f4c5ef97fa2cd4b64"></a>kInverseSquareDropoffWeight&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac42544cd06768a1ed8fed4554f388092" name="ac42544cd06768a1ed8fed4554f388092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42544cd06768a1ed8fed4554f388092">&#9670;&#160;</a></span>addDataToLayer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::addDataToLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayerType *&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accf8b6f75f8582239582862b49409c9b" name="accf8b6f75f8582239582862b49409c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf8b6f75f8582239582862b49409c9b">&#9670;&#160;</a></span>addDataToLayer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::addDataToLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; *&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c7858b23f9966e9d530bf999c6d9dc1" name="a5c7858b23f9966e9d530bf999c6d9dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7858b23f9966e9d530bf999c6d9dc1">&#9670;&#160;</a></span>allocateBlocksWhereRequired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::allocateBlocksWhereRequired </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; *&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates blocks in the block_indices list which are not already allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_indices</td><td>A vector of the 3D indices of blocks we wanna allocate. </td></tr>
    <tr><td class="paramname">layer</td><td>A pointer to the layer where we wanna allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4635fca5584da87fcaff8ed8f4be69ac" name="a4635fca5584da87fcaff8ed8f4be69ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4635fca5584da87fcaff8ed8f4be69ac">&#9670;&#160;</a></span>bindDefaultFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1LayerSerializationFunctions.html">LayerSerializationFunctions</a> nvblox::bindDefaultFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind default functions for the given types. </p>

</div>
</div>
<a id="affdb7ee2056af83bce6f82d8fc109a7d" name="affdb7ee2056af83bce6f82d8fc109a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb7ee2056af83bce6f82d8fc109a7d">&#9670;&#160;</a></span>blockSizeToVoxelSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ float nvblox::blockSizeToVoxelSize </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aefb02650fdf067d9b1ca5ef3dcde47" name="a8aefb02650fdf067d9b1ca5ef3dcde47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aefb02650fdf067d9b1ca5ef3dcde47">&#9670;&#160;</a></span>callFunctionOnAllBlocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">BlockCallbackFunction</a>&lt; BlockType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5dd1c630c4d9f195fc5129f9a91c2e" name="a5c5dd1c630c4d9f195fc5129f9a91c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5dd1c630c4d9f195fc5129f9a91c2e">&#9670;&#160;</a></span>callFunctionOnAllBlocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">ConstBlockCallbackFunction</a>&lt; BlockType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6284af341feff2614afbe0a62e8b17f5" name="a6284af341feff2614afbe0a62e8b17f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6284af341feff2614afbe0a62e8b17f5">&#9670;&#160;</a></span>callFunctionOnAllVoxels() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#a388c9e787748f6b4f6a6b1a040ba514e">VoxelCallbackFunction</a>&lt; VoxelType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function on all voxels in a layer (non-const). </p>

</div>
</div>
<a id="ac17f851e9d9f630b069291e2582d4744" name="ac17f851e9d9f630b069291e2582d4744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17f851e9d9f630b069291e2582d4744">&#9670;&#160;</a></span>callFunctionOnAllVoxels() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllVoxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#ad1737bc6ae4c9df772db7f4990c533c9">ConstVoxelCallbackFunction</a>&lt; VoxelType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function on all voxels in a layer (const). </p>

</div>
</div>
<a id="a61c9416b53472314d8dfa30e886d6616" name="a61c9416b53472314d8dfa30e886d6616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c9416b53472314d8dfa30e886d6616">&#9670;&#160;</a></span>callFunctionOnAllVoxels() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllVoxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#afab6370e27f6f8631a1364c0d2976db7">ConstBlockCallbackFunction</a>&lt; VoxelType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8804a7406d60e6a2ab265f36bb30ed0" name="ab8804a7406d60e6a2ab265f36bb30ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8804a7406d60e6a2ab265f36bb30ed0">&#9670;&#160;</a></span>callFunctionOnAllVoxels() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::callFunctionOnAllVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#aab3b444884b9c0b9caae730c62b5beec">BlockCallbackFunction</a>&lt; VoxelType &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae75b710e0da73064821f31e9baf821c1" name="ae75b710e0da73064821f31e9baf821c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75b710e0da73064821f31e9baf821c1">&#9670;&#160;</a></span>camerasAreEquivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::camerasAreEquivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>T_L_C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>T_L_C2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b9f32c0da2867c8c8ff876bcef6a80" name="a04b9f32c0da2867c8c8ff876bcef6a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b9f32c0da2867c8c8ff876bcef6a80">&#9670;&#160;</a></span>check_cuda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::check_cuda </td>
          <td>(</td>
          <td class="paramtype">cudaError_t&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa302f8bddb39d26891618146393d24ce" name="aa302f8bddb39d26891618146393d24ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa302f8bddb39d26891618146393d24ce">&#9670;&#160;</a></span>deserializeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::deserializeBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d4b773d5dc129c91a64fcb2cfec2a50" name="a2d4b773d5dc129c91a64fcb2cfec2a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4b773d5dc129c91a64fcb2cfec2a50">&#9670;&#160;</a></span>deserializeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::deserializeBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a172bba665e591f7562a8c890a8584276" name="a172bba665e591f7562a8c890a8584276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172bba665e591f7562a8c890a8584276">&#9670;&#160;</a></span>deserializeLayerParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &gt; nvblox::deserializeLayerParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td>
          <td class="paramname"><em>memory_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af160e691719a214cb89aef11604a012b" name="af160e691719a214cb89aef11604a012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af160e691719a214cb89aef11604a012b">&#9670;&#160;</a></span>getAABBOfAllocatedBlocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfAllocatedBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the outer AABB of all of the allocated blocks in the layer. </p>

</div>
</div>
<a id="a8f7550f88d899cddf1fe0065c6cb1bc6" name="a8f7550f88d899cddf1fe0065c6cb1bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7550f88d899cddf1fe0065c6cb1bc6">&#9670;&#160;</a></span>getAABBOfBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfBlock </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>block_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Axis-Aligned Bounding Box of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>Metric size of the block. </td></tr>
    <tr><td class="paramname">block_index</td><td>The index of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AABB. </dd></dl>

</div>
</div>
<a id="ab3fece148d48fdbf2616cf975115cfaa" name="ab3fece148d48fdbf2616cf975115cfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fece148d48fdbf2616cf975115cfaa">&#9670;&#160;</a></span>getAABBOfBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfBlocks </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get AABB that covers ALL blocks in the block index list. </p>

</div>
</div>
<a id="ad939d259752408dc069ec818acd9a949" name="ad939d259752408dc069ec818acd9a949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad939d259752408dc069ec818acd9a949">&#9670;&#160;</a></span>getAABBOfObservedVoxels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfObservedVoxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#af96d82304f21279b2c74ef070f9aff19">ColorLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>min_weight</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the outer AABB of all of the blocks that contain observed voxels in an <a class="el" href="structnvblox_1_1Color.html" title="Color, stored as 8-bit RGBA, with helper functions for commonly-used colors.">Color</a> layer. </p>

</div>
</div>
<a id="ad3ec28f37483058ef2883ea873ea3f13" name="ad3ec28f37483058ef2883ea873ea3f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ec28f37483058ef2883ea873ea3f13">&#9670;&#160;</a></span>getAABBOfObservedVoxels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfObservedVoxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a196d96c2a51e35486f565c0d752a36a5">EsdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the outer AABB of all of the blocks that contain observed voxels in an ESDF layer. </p>

</div>
</div>
<a id="a9d5b7e63075bc1119b0edbe58f8e99b1" name="a9d5b7e63075bc1119b0edbe58f8e99b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5b7e63075bc1119b0edbe58f8e99b1">&#9670;&#160;</a></span>getAABBOfObservedVoxels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> nvblox::getAABBOfObservedVoxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a41cd24e7c00a316481ae92646108583f">TsdfLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>min_weight</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the outer AABB of all of the blocks that contain observed voxels in an TSDF layer. </p>

</div>
</div>
<a id="a8fb9863dc9e75130239b9931e713aaa5" name="a8fb9863dc9e75130239b9931e713aaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb9863dc9e75130239b9931e713aaa5">&#9670;&#160;</a></span>getAllocatedBlocksWithinAABB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getAllocatedBlocksWithinAABB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the allocated blocks that are within a given AABB. </p>

</div>
</div>
<a id="a2e9cc929b1b05fdd42bb8b111797b385" name="a2e9cc929b1b05fdd42bb8b111797b385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9cc929b1b05fdd42bb8b111797b385">&#9670;&#160;</a></span>getBlockAndVoxelIndexFromPositionInLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ void nvblox::getBlockAndVoxelIndexFromPositionInLayer </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> *&#160;</td>
          <td class="paramname"><em>block_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> *&#160;</td>
          <td class="paramname"><em>voxel_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2ae3aa42c62ddb96209361fef3babcd" name="ab2ae3aa42c62ddb96209361fef3babcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ae3aa42c62ddb96209361fef3babcd">&#9670;&#160;</a></span>getBlockAtPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::getBlockAtPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockType **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Block. </p>

</div>
</div>
<a id="adec09652af0b568f766bdf8f5ac73091" name="adec09652af0b568f766bdf8f5ac73091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec09652af0b568f766bdf8f5ac73091">&#9670;&#160;</a></span>getBlockIndexFromPositionInLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> nvblox::getBlockIndexFromPositionInLayer </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac921e530b1b004c388b36225fdf46ce8" name="ac921e530b1b004c388b36225fdf46ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac921e530b1b004c388b36225fdf46ce8">&#9670;&#160;</a></span>getBlockIndicesTouchedByBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getBlockIndicesTouchedByBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all of the blocks that are touched by an AABB, no matter how little. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>Metric size of the block. </td></tr>
    <tr><td class="paramname">aabb</td><td>Axis-Aligned Bounding Box that does the touching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of all the touched block indices. </dd></dl>

</div>
</div>
<a id="ada0f5a2c479618906828b62e82690732" name="ada0f5a2c479618906828b62e82690732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f5a2c479618906828b62e82690732">&#9670;&#160;</a></span>getBlockPtrsFromIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ std::vector&lt; BlockType * &gt; nvblox::getBlockPtrsFromIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; *&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of BlockIndices on host, to a list of (non-const) device pointers on host. </p>
<p>Note that this function will check fail if one passed BlockIndices indices is not allocated. The function is intended for use in specific parts of the code where blocks in the camera view have already been allocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_indices</td><td>A vector of the 3D indices of blocks who's pointers we want </td></tr>
    <tr><td class="paramname">layer_ptr</td><td>A pointer to the layer containing the blocks. </td></tr>
    <tr><td class="paramname">return</td><td>a vector of block pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76bbaae47fb1f678138db31fa3a7bad6" name="a76bbaae47fb1f678138db31fa3a7bad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bbaae47fb1f678138db31fa3a7bad6">&#9670;&#160;</a></span>getBlockPtrsFromIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ std::vector&lt; const BlockType * &gt; nvblox::getBlockPtrsFromIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of BlockIndices on host, to a list of (const) device pointers on host. </p>
<p>Note that this function will check fail if one passed BlockIndices indices is not allocated. The function is intended for use in specific parts of the code where blocks in the camera view have already been allocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_indices</td><td>A vector of the 3D indices of blocks who's pointers we want </td></tr>
    <tr><td class="paramname">layer_ptr</td><td>A pointer to the layer containing the blocks. </td></tr>
    <tr><td class="paramname">return</td><td>a vector of block pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf1df1b500c275abd3552c74a01658e6" name="adf1df1b500c275abd3552c74a01658e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1df1b500c275abd3552c74a01658e6">&#9670;&#160;</a></span>getBlocksOutsideRadius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getBlocksOutsideRadius </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeea96648dace1f0db185c0932733594f" name="aeea96648dace1f0db185c0932733594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea96648dace1f0db185c0932733594f">&#9670;&#160;</a></span>getBlocksWithinRadius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getBlocksWithinRadius </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36db94b92cfb98fd29ece567c172c7e1" name="a36db94b92cfb98fd29ece567c172c7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db94b92cfb98fd29ece567c172c7e1">&#9670;&#160;</a></span>getBlocksWithinRadiusOfAABB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getBlocksWithinRadiusOfAABB </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#acc1a2583960d9c101856c61101b56739">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46d7479c2dabf9b664db883e40aec0b9" name="a46d7479c2dabf9b664db883e40aec0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d7479c2dabf9b664db883e40aec0b9">&#9670;&#160;</a></span>getCenterPostionFromBlockIndexAndVoxelIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> nvblox::getCenterPostionFromBlockIndexAndVoxelIndex </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>block_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CENTER of the voxel. </p>

</div>
</div>
<a id="a68738a6de44353303d7c4c8662508bfa" name="a68738a6de44353303d7c4c8662508bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68738a6de44353303d7c4c8662508bfa">&#9670;&#160;</a></span>getLayerDataIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getLayerDataIndices </td>
          <td>(</td>
          <td class="paramtype">const LayerType &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a609662db86c4b574f6c08694edf2f0ce" name="a609662db86c4b574f6c08694edf2f0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609662db86c4b574f6c08694edf2f0ce">&#9670;&#160;</a></span>getLayerDataIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &gt; nvblox::getLayerDataIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae651726a7fe422df90b521536bb69ba" name="aae651726a7fe422df90b521536bb69ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae651726a7fe422df90b521536bb69ba">&#9670;&#160;</a></span>getPositionFromBlockIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> nvblox::getPositionFromBlockIndex </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>block_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2da77dcb972ccd5958b566245ab02046" name="a2da77dcb972ccd5958b566245ab02046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da77dcb972ccd5958b566245ab02046">&#9670;&#160;</a></span>getPositionFromBlockIndexAndVoxelIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> nvblox::getPositionFromBlockIndexAndVoxelIndex </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>block_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the position of the minimum corner (i.e., the smallest towards negative infinity of each axis). </p>

</div>
</div>
<a id="a1cd778ad4b5a410398362558151736b9" name="a1cd778ad4b5a410398362558151736b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd778ad4b5a410398362558151736b9">&#9670;&#160;</a></span>getVoxelAtBlockAndVoxelIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VoxelType * nvblox::getVoxelAtBlockAndVoxelIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>block_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for voxelized types. </p>

</div>
</div>
<a id="a923cd9f93e5934518e22f7a5f33d8d78" name="a923cd9f93e5934518e22f7a5f33d8d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923cd9f93e5934518e22f7a5f33d8d78">&#9670;&#160;</a></span>getVoxelAtPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::getVoxelAtPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1BlockLayer.html">BlockLayer</a>&lt; <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VoxelType **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Voxel. </p>

</div>
</div>
<a id="a4fb7cb25a9de0333a9f174033c2e3332" name="a4fb7cb25a9de0333a9f174033c2e3332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb7cb25a9de0333a9f174033c2e3332">&#9670;&#160;</a></span>getVoxelIndexFromPositionInLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> nvblox::getVoxelIndexFromPositionInLayer </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a4b87a147b3363eaf7442ed521d3a9968">Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming a fixed-size voxel block, get the voxel index of a voxel at that position within a block. </p>

</div>
</div>
<a id="ad640ac31fc054c7e04ac95dedab14a46" name="ad640ac31fc054c7e04ac95dedab14a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad640ac31fc054c7e04ac95dedab14a46">&#9670;&#160;</a></span>logOddsFromProbability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ float nvblox::logOddsFromProbability </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>probability</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03307af848ae5080f2fa1e4fbdcf5534" name="a03307af848ae5080f2fa1e4fbdcf5534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03307af848ae5080f2fa1e4fbdcf5534">&#9670;&#160;</a></span>make_unified() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Single_object nvblox::make_unified </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac346f7eb93e2d599cc34b5a410d3796b" name="ac346f7eb93e2d599cc34b5a410d3796b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac346f7eb93e2d599cc34b5a410d3796b">&#9670;&#160;</a></span>make_unified() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Known_bound nvblox::make_unified </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b185611dd35d8e9369adb059df6afea" name="a9b185611dd35d8e9369adb059df6afea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b185611dd35d8e9369adb059df6afea">&#9670;&#160;</a></span>make_unified() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Single_object nvblox::make_unified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td>
          <td class="paramname"><em>memory_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed54c98a201dc1c1599ee03f8f35fa70" name="aed54c98a201dc1c1599ee03f8f35fa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed54c98a201dc1c1599ee03f8f35fa70">&#9670;&#160;</a></span>make_unified() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Unknown_bound nvblox::make_unified </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f91565d8f9966d8f21c020c65ddbb7a" name="a7f91565d8f9966d8f21c020c65ddbb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f91565d8f9966d8f21c020c65ddbb7a">&#9670;&#160;</a></span>make_unified() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1__Unified__if.html">_Unified_if</a>&lt; T &gt;::_Unknown_bound nvblox::make_unified </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td>
          <td class="paramname"><em>memory_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a540b39e6117ea84fe5d88ff931fd891b" name="a540b39e6117ea84fe5d88ff931fd891b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540b39e6117ea84fe5d88ff931fd891b">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8055b1f1a067efa3636ab31a9281fc3f" name="a8055b1f1a067efa3636ab31a9281fc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8055b1f1a067efa3636ab31a9281fc3f">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1693c36a85f8b6f0f993ee6391188eb0" name="a1693c36a85f8b6f0f993ee6391188eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1693c36a85f8b6f0f993ee6391188eb0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nvblox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Camera.html">Camera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1134fae2a499abdb031e39a5b534643a" name="a1134fae2a499abdb031e39a5b534643a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1134fae2a499abdb031e39a5b534643a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nvblox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">WeightingFunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>weighting_function_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5943b902513096b8979a4493ca55d75c" name="a5943b902513096b8979a4493ca55d75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5943b902513096b8979a4493ca55d75c">&#9670;&#160;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ bool nvblox::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Lidar.html">Lidar</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Lidar.html">Lidar</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad86e3c49ecef5c11577d200abd4a5d02" name="ad86e3c49ecef5c11577d200abd4a5d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86e3c49ecef5c11577d200abd4a5d02">&#9670;&#160;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41acf15abdacfa53e513ebbee32ca1a2" name="a41acf15abdacfa53e513ebbee32ca1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41acf15abdacfa53e513ebbee32ca1a2">&#9670;&#160;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nvblox::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a522a0eb0ae8183bf931a23f02c83f942" name="a522a0eb0ae8183bf931a23f02c83f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522a0eb0ae8183bf931a23f02c83f942">&#9670;&#160;</a></span>probabilityFromLogOdds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ float nvblox::probabilityFromLogOdds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_odds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ed96b00838d2adfba230bd0709a16c4" name="a6ed96b00838d2adfba230bd0709a16c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed96b00838d2adfba230bd0709a16c4">&#9670;&#160;</a></span>registerCommonTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::registerCommonTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers all the common layer types for serialization. </p>
<p>Must be called before you serialize or de-serialize anything. </p>

</div>
</div>
<a id="a4a5b5a3a002bf96d85d9f518551649ce" name="a4a5b5a3a002bf96d85d9f518551649ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5b5a3a002bf96d85d9f518551649ce">&#9670;&#160;</a></span>serializeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; nvblox::serializeBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90ef5974444b610c02404d45eb926161" name="a90ef5974444b610c02404d45eb926161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ef5974444b610c02404d45eb926161">&#9670;&#160;</a></span>serializeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; nvblox::serializeBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1unified__ptr.html">unified_ptr</a>&lt; const <a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; VoxelType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99810f5f74b03fbf6dcd807a6c83c4eb" name="a99810f5f74b03fbf6dcd807a6c83c4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99810f5f74b03fbf6dcd807a6c83c4eb">&#9670;&#160;</a></span>serializeLayerDataAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; nvblox::serializeLayerDataAtIndex </td>
          <td>(</td>
          <td class="paramtype">const LayerType &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ef435b778e89ff71d0326897f3ccbfa" name="a7ef435b778e89ff71d0326897f3ccbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef435b778e89ff71d0326897f3ccbfa">&#9670;&#160;</a></span>serializeLayerDataAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacenvblox.html#a91e5d9c92640e17fb508f6ba4016bd82">Byte</a> &gt; nvblox::serializeLayerDataAtIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a9d25b1bf98870a5d7242e728915cc1d5">Index3D</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a8f5534a4b6789066b937136b35b85" name="ad5a8f5534a4b6789066b937136b35b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a8f5534a4b6789066b937136b35b85">&#9670;&#160;</a></span>serializeLayerParameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a> nvblox::serializeLayerParameters </td>
          <td>(</td>
          <td class="paramtype">const LayerType &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54a3afd4da91d0a6d84e422fb18a1ff0" name="a54a3afd4da91d0a6d84e422fb18a1ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a3afd4da91d0a6d84e422fb18a1ff0">&#9670;&#160;</a></span>serializeLayerParameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnvblox_1_1LayerParameterStruct.html">LayerParameterStruct</a> nvblox::serializeLayerParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1VoxelBlockLayer.html">VoxelBlockLayer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d06424d9c839e12bd1d548dfd795a97" name="a8d06424d9c839e12bd1d548dfd795a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d06424d9c839e12bd1d548dfd795a97">&#9670;&#160;</a></span>setBlockBytesZeroOnGPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BlockType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::setBlockBytesZeroOnGPU </td>
          <td>(</td>
          <td class="paramtype">BlockType *&#160;</td>
          <td class="paramname"><em>block_device_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the memory of the block to 0 on the GPU. </p>

</div>
</div>
<a id="ab77c97b5cf7abe06613cdbd8bbf6f443" name="ab77c97b5cf7abe06613cdbd8bbf6f443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77c97b5cf7abe06613cdbd8bbf6f443">&#9670;&#160;</a></span>setColorBlockGrayOnGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::setColorBlockGrayOnGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvblox_1_1VoxelBlock.html">VoxelBlock</a>&lt; <a class="el" href="structnvblox_1_1ColorVoxel.html">ColorVoxel</a> &gt; *&#160;</td>
          <td class="paramname"><em>block_device_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all of the default colors to gray on a GPU. </p>

</div>
</div>
<a id="a9cae54124801d270d0a29985d0ad2145" name="a9cae54124801d270d0a29985d0ad2145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cae54124801d270d0a29985d0ad2145">&#9670;&#160;</a></span>sizeArgumentFromVoxelSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LayerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float nvblox::sizeArgumentFromVoxelSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad5347793b864b8030ae1c34b37eace" name="a7ad5347793b864b8030ae1c34b37eace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5347793b864b8030ae1c34b37eace">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string nvblox::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a>&#160;</td>
          <td class="paramname"><em>memory_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f6e3a3efb322790a7a033be6874d5d2" name="a3f6e3a3efb322790a7a033be6874d5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6e3a3efb322790a7a033be6874d5d2">&#9670;&#160;</a></span>transformPointcloudOnGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::transformPointcloudOnGPU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenvblox.html#a187a99e3c413b9f0d52249e3a53816e3">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>T_out_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnvblox_1_1Pointcloud.html">Pointcloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pointcloud_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvblox_1_1Pointcloud.html">Pointcloud</a> *&#160;</td>
          <td class="paramname"><em>pointcloud_out_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the points in a pointcloud into another frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T_out_in</td><td>Transform that takes a point in frame "in" to frame "out". </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pointcloud_in</td><td><a class="el" href="classnvblox_1_1Pointcloud.html" title="Pointcloud that lives in either device, host or unified memory.">Pointcloud</a> in frame "in". </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pointcloud_out</td><td>Pointer to pointcloud in frame "out". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc0d1280b92ffbb4c9f1aa143e38768c" name="acc0d1280b92ffbb4c9f1aa143e38768c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0d1280b92ffbb4c9f1aa143e38768c">&#9670;&#160;</a></span>voxelSizeToBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ float nvblox::voxelSizeToBlockSize </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>voxel_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b35a6b08cd5433ab6230cf002c759fc" name="a7b35a6b08cd5433ab6230cf002c759fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b35a6b08cd5433ab6230cf002c759fc">&#9670;&#160;</a></span>warmupCuda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvblox::warmupCuda </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab715cffa6ff1964ebcd0a536fd2f2fd1" name="ab715cffa6ff1964ebcd0a536fd2f2fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab715cffa6ff1964ebcd0a536fd2f2fd1">&#9670;&#160;</a></span>kDefaultImageMemoryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> nvblox::kDefaultImageMemoryType = <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103">MemoryType::kDevice</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fccc8c7879835b1e30a86ac96f9a0f9" name="a4fccc8c7879835b1e30a86ac96f9a0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fccc8c7879835b1e30a86ac96f9a0f9">&#9670;&#160;</a></span>kDefaultPointcloudMemoryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223">MemoryType</a> nvblox::kDefaultPointcloudMemoryType = <a class="el" href="namespacenvblox.html#adb582c0d90a20d74dff447c0ac393223a040394711ad65e20323fe0114e507103">MemoryType::kDevice</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca11bf4da09302e5daa400017eb6092b" name="aca11bf4da09302e5daa400017eb6092b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca11bf4da09302e5daa400017eb6092b">&#9670;&#160;</a></span>kDefaultWeightingFunctionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacenvblox.html#ae76b8cc1c9b44b61cf58f4662f97bbc5">WeightingFunctionType</a> nvblox::kDefaultWeightingFunctionType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    WeightingFunctionType::kInverseSquareWeight</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvblox.html">nvblox</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
